using System;
using System.IO;
using Mono.Cecil;

namespace CompatibilityStub {
	static class Program {

		static int IndentLevel;
		static string Namespace;
		static TextWriter Out;

		static void Main (string[] args)
		{
			Out = new StringWriter ();
			var ad = AssemblyDefinition.ReadAssembly (args [0]);
			Namespace = args [1];

			Out.WriteLine ("// autogenerated stub - do not edit");
			Out.WriteLine ("#if !XAMCORE_4_0");
			Out.WriteLine ("using System;");
			Out.WriteLine ("using System.Runtime.Versioning;");
			Out.WriteLine ();
			Out.WriteLine ("#pragma warning disable 0067");
			Out.WriteLine ();
			Out.WriteLine ("namespace QTKit {");
			Out.WriteLine ();

			IndentLevel++;
			foreach (var type in ad.MainModule.Types) {
				Process (type);
			}
			IndentLevel--;
			Out.WriteLine ("}");
			Out.WriteLine ();
			Out.WriteLine ("#endif");
			File.WriteAllText ("stub.txt", Out.ToString ());
		}

		static bool IsMulticastDelegate (this TypeDefinition type)
		{
			var bt = type.BaseType;
			return ((bt != null) && (bt.FullName == "System.MulticastDelegate"));
		}

		static void PrintParameters (MethodDefinition method)
		{
			Out.Write ('(');
			if (method.HasParameters) {
				var p = method.Parameters;
				for (int i = 0; i < p.Count; i++) {
					if (i > 0)
						Out.Write (", ");
					var parameter = p [i];
					if (parameter.IsOut) {
						Out.Write ("out ");
						Out.Write (parameter.ParameterType.GetElementType ().FullName);
					} else
						Out.Write (parameter.ParameterType.FullName);
					Out.Write (' ');
					Out.Write (parameter.Name);
				}
			}
			Out.Write (')');
		}

		static void Process (TypeDefinition type, bool isTopLevel = true)
		{
			if (!type.IsPublic && !type.IsNestedPublic)
				return;
			// Filter
			if ((type.Namespace != Namespace) && !(type.IsNested && type.DeclaringType.Namespace == Namespace))
				return;

			if (isTopLevel)
				AddDotNetObsolete ();
			if (type.IsEnum) {
				if (type.HasCustomAttributes) {
					foreach (var ca in type.CustomAttributes) {
						switch (ca.AttributeType.FullName) {
						case "System.FlagsAttribute":
							Out.Indent ();
							Out.WriteLine ("[System.Flags]");
							break;
						case "ObjCRuntime.NativeAttribute":
							Out.Indent ();
							Out.WriteLine ("[ObjCRuntime.Native]");
							break;
						}
					}
				}
				Out.Indent ();
				Out.Write ("public enum ");
				Out.Write (type.Name);
				// there are always (at least one) field
				foreach (var field in type.Fields) {
					// skip `value__`
					if (field.IsSpecialName) {
						Out.Write (" : ");
						Out.Write (field.FieldType.FullName);
						Out.WriteLine (" {");
						IndentLevel++;
					} else {
						Out.Indent ();
						Out.Write (field.Name);
						Out.Write (" = ");
						Out.Write (field.Constant);
						Out.WriteLine (',');
					}
				}
				IndentLevel--;
				Out.Indent ();
				Out.WriteLine ('}');
				Out.WriteLine ();
				return;
			}

			Out.Indent ();
			Out.Write ("public ");
			if (type.IsValueType)
				Out.Write ("struct ");
			else if (type.IsMulticastDelegate ()) {
				Out.Write ("delegate ");
				foreach (var m in type.Methods) {
					if (m.Name != "Invoke")
						continue;
					Out.Write (m.ReturnType.FullName);
					Out.Write (' ');
					Out.Write (type.Name);
					Out.Write (' ');
					PrintParameters (m);
					Out.WriteLine (';');
					break;
				}
				Out.WriteLine ();
				return;
			} else if (type.IsClass) {
				if (type.IsSealed) {
					if (type.IsAbstract)
						Out.Write ("static ");
					else
						Out.Write ("sealed ");
				} else if (type.IsAbstract)
					Out.Write ("abstract ");
				Out.Write ("class ");
			} else if (type.IsInterface)
				Out.Write ("interface ");

			Out.Write (type.Name);

			if (!type.IsEnum && !type.IsValueType) {
			
				var bt = type.BaseType;
				if (bt != null) {
					Out.Write (" : ");
					Out.Write (bt.FullName);
				}
				if (type.HasInterfaces) {
					if (bt == null)
						Out.Write (" : ");
					for (int i = 0; i < type.Interfaces.Count; i++) {
						if ((i > 0) || (bt != null))
							Out.Write (", ");
						Out.Write (type.Interfaces [i].InterfaceType.FullName);
					}
				}
			}
			Out.WriteLine (" {");
			IndentLevel++;

			if (type.HasFields) {
				foreach (var field in type.Fields) {
					if (!field.IsPublic)
						continue;
					Out.Indent ();
					Out.Write ("public ");
					if (field.IsStatic)
						Out.Write ("static ");
					if (field.IsInitOnly)
						Out.Write ("readonly ");
					Out.Write (field.FieldType.FullName);
					Out.Write (' ');
					Out.Write (field.Name);
					Out.WriteLine (';');
					Out.WriteLine ();
				}
			}

			bool default_ctor = false;
			if (type.HasMethods) {
				foreach (var method in type.Methods) {
					if (!method.IsPublic && !method.IsFamily && !method.IsFamilyOrAssembly)
						continue;
					else if (method.IsSpecialName && !method.IsConstructor)
						continue;
					Out.Indent ();
					if (method.IsPublic)
						Out.Write ("public ");
					else if (method.IsFamily)
						Out.Write ("protected ");
					else if (method.IsFamilyOrAssembly)
						Out.Write ("protected internal ");

					if (method.IsStatic)
						Out.Write ("static ");

					if (method.IsVirtual) {
						if (method.IsReuseSlot)
							Out.Write ("override ");
						else
							Out.Write ("virtual ");
					}
					var rt = method.ReturnType.FullName;
					if (method.IsConstructor) {
						Out.Write (type.Name);
						default_ctor |= !method.HasParameters;
					} else {
						if (rt == "System.Void")
							rt = "void"; // CS0673
						Out.Write (rt);
						Out.Write (' ');
						Out.Write (method.Name);
					}
					Out.Write (" (");
					if (method.HasParameters) {
						var p = method.Parameters;
						for (int i = 0; i < p.Count; i++) {
							if (i == 0) {
								if (method.IsStatic && (type.IsAbstract && type.IsSealed) && method.HasCustomAttributes) {
									foreach (var ca in method.CustomAttributes) {
										if (ca.AttributeType.FullName != "System.Runtime.CompilerServices.ExtensionAttribute")
											continue;
										Out.Write ("this ");
										break;
									}
								}
							} else
								Out.Write (", ");
							var parameter = p [i];
							if (parameter.IsOut) {
								Out.Write ("out ");
								Out.Write (parameter.ParameterType.GetElementType ().FullName);
							} else {
								// quick have for EventHandler`1
								var fn = parameter.ParameterType.FullName.Replace ("`1", "");
								Out.Write (fn);
							}
							Out.Write (' ');
							Out.Write (parameter.Name);
						}
					}
					Out.WriteLine (")");
					Out.Indent ();
					Out.WriteLine ("{");
					if (method.IsConstructor) {
						IndentLevel++;
						Out.Indent ();
						Out.WriteLine ("throw new System.PlatformNotSupportedException (ObjCRuntime.Constants.MacOS32bitsUnavailable);");
						IndentLevel--;
					} else if (rt != "void") {
						IndentLevel++;
						if (method.HasParameters) {
							foreach (var parameter in method.Parameters) {
								if (!parameter.IsOut)
									continue;
								Out.Indent ();
								Out.Write (parameter.Name);
								Out.Write (" = default (");
								Out.Write (parameter.ParameterType.GetElementType ().FullName);
								Out.WriteLine (");");
							}
						}
						Out.Indent ();
						Out.Write ("return default (");
						Out.Write (rt);
						Out.WriteLine (");");
						IndentLevel--;
					}
					Out.Indent ();
					Out.WriteLine ("}");
					Out.WriteLine ();
				}
			}
			if (!type.IsEnum && !type.IsValueType && !(type.IsAbstract && type.IsSealed) && !type.IsInterface && !default_ctor) {
				Out.Indent ();
				Out.Write ("internal ");
				Out.Write (type.Name);
				Out.WriteLine (" ()");
				Out.Indent ();
				Out.WriteLine ("{");
				IndentLevel++;
				Out.Indent ();
				Out.WriteLine ("throw new System.PlatformNotSupportedException (ObjCRuntime.Constants.MacOS32bitsUnavailable);");
				IndentLevel--;
				Out.Indent ();
				Out.WriteLine ("}");
				Out.WriteLine ();
			}

			// no need to throw if you can't create the type (because that would throw)
			if (type.HasProperties) {
				foreach (var property in type.Properties) {
					var getter = property.GetMethod;
					// TODO setter only could exists (but it's bad design)
					if (!getter.IsPublic)
						continue;
					Out.Indent ();
					Out.Write ("public ");
					if (getter.IsStatic)
						Out.Write ("static ");
					if (getter.IsVirtual) {
						if (getter.IsReuseSlot)
							Out.Write ("override ");
						else
							Out.Write ("virtual ");
					}
					var pt = property.PropertyType.FullName;
					if (pt.StartsWith ("System.Nullable`1<", StringComparison.Ordinal)) {
						Out.Write ((property.PropertyType as GenericInstanceType).GenericArguments [0].FullName);
						Out.Write ('?');
					} else
						Out.Write (pt);
					Out.Write (' ');
					Out.Write (property.Name);
					Out.WriteLine (" {");
					IndentLevel++;
					Out.Indent ();
					Out.Write ("get { return default(");
					Out.Write (property.PropertyType.FullName.Replace ("`1", ""));
					Out.WriteLine ("); }");
					var setter = property.SetMethod;
					if ((setter != null) && setter.IsPublic) {
						Out.Indent ();
						Out.WriteLine ("set { }");
					}
					IndentLevel--;
					Out.Indent ();
					Out.WriteLine ('}');
					Out.WriteLine ();
				}
			}

			if (type.HasEvents) {
				foreach (var ev in type.Events) {
					if (!ev.AddMethod.IsPublic)
						continue;
					Out.Indent ();
					Out.Write ("public event ");
					var et = ev.EventType.FullName.Replace ("`1", "");
					Out.Write (et);
					Out.Write (' ');
					Out.Write (ev.Name);
					Out.WriteLine (';');
					Out.WriteLine ();
				}
			}

			if (type.HasNestedTypes) {
				foreach (var nt in type.NestedTypes)
					Process (nt, false);
			}
		
			IndentLevel--;
			Out.Indent ();
			Out.WriteLine ('}');
			Out.WriteLine ();
		}

		static void Indent (this TextWriter self)
		{
			for (int i = 0; i < IndentLevel; i++)
				self.Write ('\t');
		}

		static void AddDotNetObsolete ()
		{
			var levelPlaceholder = IndentLevel;
			IndentLevel = 0;
			Out.Indent ();
			Out.WriteLine ("#if !NET");
			IndentLevel = levelPlaceholder;
			Out.Indent ();
			Out.WriteLine ("[ObjCRuntime.Obsoleted (ObjCRuntime.PlatformName.MacOSX, 10,15, message: ObjCRuntime.Constants.MacOS32bitsUnavailable)]");
			IndentLevel = 0;
			Out.Indent ();
			Out.WriteLine ("#else");
			Out.WriteLine ("#if MONOMAC");
			IndentLevel = levelPlaceholder;
			Out.Indent ();
			Out.WriteLine("[Obsolete (\"Starting with macos10.15 this framework is not available on 64bits macOS versions.\", DiagnosticId = \"BI1234\", UrlFormat = \"https://github.com/xamarin/xamarin-macios/wiki/Obsolete\")]");
			IndentLevel = 0;
			Out.Indent ();
			Out.WriteLine ("#endif");
			Out.WriteLine ("#endif");
			IndentLevel = levelPlaceholder;
		}
	}
}
